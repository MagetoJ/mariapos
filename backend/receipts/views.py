from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils import timezone
from django.db import transaction
from django.db.models import Q, Sum, Count, Avg
from django.template.loader import render_to_string
from django.core.mail import EmailMessage
from django.conf import settings
from django.utils.dateparse import parse_date
from datetime import datetime, timedelta
import json
import logging

from accounts.permissions import IsManagerOrAdmin, IsStaffMember, IsCashierOrAbove
from .models import (
    Receipt, ReceiptItem, ReceiptTemplate, ReceiptPrintQueue, ReceiptEmailLog
)
from .serializers import (
    ReceiptListSerializer, ReceiptDetailSerializer, ReceiptCreateSerializer,
    ReceiptFromOrderSerializer, ReceiptVoidSerializer, ReceiptTemplateSerializer,
    ReceiptPrintQueueSerializer, ReceiptPrintRequestSerializer,
    ReceiptEmailLogSerializer, ReceiptEmailRequestSerializer,
    ReceiptStatsSerializer, ReceiptReportSerializer, ReceiptPreviewSerializer,
    BulkReceiptActionSerializer
)

logger = logging.getLogger(__name__)

class ReceiptViewSet(viewsets.ModelViewSet):
    """Receipt management ViewSet"""
    
    permission_classes = [IsAuthenticated, IsStaffMember]
    
    def get_queryset(self):
        """Get receipts with filtering"""
        queryset = Receipt.objects.select_related(
            'order', 'payment', 'generated_by', 'voided_by'
        ).prefetch_related('items')
        
        # Filter by receipt type
        receipt_type = self.request.query_params.get('receipt_type')
        if receipt_type:
            queryset = queryset.filter(receipt_type=receipt_type)
        
        # Filter by status
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        # Filter by date range
        start_date = self.request.query_params.get('start_date')
        end_date = self.request.query_params.get('end_date')
        if start_date:
            queryset = queryset.filter(created_at__date__gte=parse_date(start_date))
        if end_date:
            queryset = queryset.filter(created_at__date__lte=parse_date(end_date))
        
        # Filter by customer
        customer_name = self.request.query_params.get('customer_name')
        if customer_name:
            queryset = queryset.filter(
                customer_name__icontains=customer_name
            )
        
        # Filter by payment method
        payment_method = self.request.query_params.get('payment_method')
        if payment_method:
            queryset = queryset.filter(payment_method=payment_method)
        
        # Filter by generated user
        generated_by = self.request.query_params.get('generated_by')
        if generated_by:
            queryset = queryset.filter(generated_by_id=generated_by)
        
        # Filter by order
        order_id = self.request.query_params.get('order')
        if order_id:
            queryset = queryset.filter(order_id=order_id)
        
        # Filter for email/print status
        is_emailed = self.request.query_params.get('is_emailed')
        if is_emailed is not None:
            queryset = queryset.filter(is_emailed=is_emailed.lower() == 'true')
        
        is_printed = self.request.query_params.get('is_printed')
        if is_printed is not None:
            queryset = queryset.filter(is_printed=is_printed.lower() == 'true')
        
        return queryset.order_by('-created_at')
    
    def get_serializer_class(self):
        """Return appropriate serializer class"""
        if self.action == 'list':
            return ReceiptListSerializer
        elif self.action == 'create':
            return ReceiptCreateSerializer
        elif self.action in ['from_order', 'generate_from_order']:
            return ReceiptFromOrderSerializer
        elif self.action == 'void':
            return ReceiptVoidSerializer
        elif self.action in ['email', 'send_email']:
            return ReceiptEmailRequestSerializer
        elif self.action in ['print', 'queue_print']:
            return ReceiptPrintRequestSerializer
        elif self.action == 'bulk_action':
            return BulkReceiptActionSerializer
        return ReceiptDetailSerializer
    
    def perform_create(self, serializer):
        """Create receipt with generated by user"""
        serializer.save(generated_by=self.request.user)
    
    @action(detail=False, methods=['post'])
    def from_order(self, request):
        """Generate receipt from order"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        order_id = serializer.validated_data['order_id']
        payment_id = serializer.validated_data.get('payment_id')
        receipt_type = serializer.validated_data['receipt_type']
        email_to_customer = serializer.validated_data.get('email_to_customer', False)
        print_receipt = serializer.validated_data.get('print_receipt', False)
        
        try:
            with transaction.atomic():
                # Get order and payment
                from orders.models import Order
                from payments.models import Payment
                
                order = Order.objects.get(id=order_id)
                payment = None
                if payment_id:
                    payment = Payment.objects.get(id=payment_id, order=order)
                
                # Create receipt from order data
                receipt_data = {
                    'order': order,
                    'payment': payment,
                    'receipt_type': receipt_type,
                    'customer_name': getattr(order, 'customer_name', '') or 'Walk-in Customer',
                    'customer_email': getattr(order, 'customer_email', ''),
                    'customer_phone': getattr(order, 'customer_phone', ''),
                    'customer_room': getattr(order, 'room_number', ''),
                    'business_name': getattr(settings, 'BUSINESS_NAME', 'Maria Havens POS'),
                    'business_address': getattr(settings, 'BUSINESS_ADDRESS', ''),
                    'business_phone': getattr(settings, 'BUSINESS_PHONE', ''),
                    'business_email': getattr(settings, 'BUSINESS_EMAIL', ''),
                    'tax_id': getattr(settings, 'TAX_ID', ''),
                    'subtotal': order.subtotal,
                    'tax_amount': order.tax_amount,
                    'service_charge': getattr(order, 'service_charge', 0),
                    'discount_amount': getattr(order, 'discount_amount', 0),
                    'total_amount': order.total,
                    'amount_paid': payment.amount if payment else 0,
                    'payment_method': payment.payment_method if payment else 'pending',
                    'payment_reference': payment.reference if payment else '',
                    'generated_by': request.user
                }
                
                # Calculate change
                if payment:
                    receipt_data['change_amount'] = max(0, payment.amount - order.total)
                
                receipt = Receipt.objects.create(**receipt_data)
                
                # Create receipt items from order items
                for order_item in order.items.all():
                    ReceiptItem.objects.create(
                        receipt=receipt,
                        item_name=order_item.menu_item.name,
                        quantity=order_item.quantity,
                        unit_price=order_item.price,
                        line_total=order_item.quantity * order_item.price,
                        is_taxable=getattr(order_item.menu_item, 'is_taxable', True),
                        tax_rate=getattr(order_item.menu_item, 'tax_rate', 0),
                        category=order_item.menu_item.category
                    )
                
                # Handle email if requested
                if email_to_customer and receipt_data['customer_email']:
                    self._send_receipt_email(receipt, receipt_data['customer_email'])
                
                # Handle print if requested
                if print_receipt:
                    self._queue_receipt_print(receipt, 'POS-Printer')
                
                serializer = ReceiptDetailSerializer(receipt)
                return Response(serializer.data, status=status.HTTP_201_CREATED)
        
        except Order.DoesNotExist:
            return Response(
                {'error': 'Order not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Payment.DoesNotExist:
            return Response(
                {'error': 'Payment not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error generating receipt from order: {str(e)}")
            return Response(
                {'error': 'Failed to generate receipt'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated, IsManagerOrAdmin])
    def void(self, request, pk=None):
        """Void a receipt"""
        receipt = self.get_object()
        serializer = self.get_serializer(
            data=request.data, 
            context={'receipt': receipt}
        )
        serializer.is_valid(raise_exception=True)
        
        reason = serializer.validated_data['reason']
        
        try:
            with transaction.atomic():
                receipt.status = 'voided'
                receipt.void_reason = reason
                receipt.voided_by = request.user
                receipt.voided_at = timezone.now()
                receipt.save()
                
                # Log the void action
                logger.info(
                    f"Receipt {receipt.receipt_number} voided by {request.user.email}: {reason}"
                )
                
                return Response({
                    'message': 'Receipt voided successfully',
                    'receipt_number': receipt.receipt_number,
                    'void_reason': reason
                })
        
        except Exception as e:
            logger.error(f"Error voiding receipt {pk}: {str(e)}")
            return Response(
                {'error': 'Failed to void receipt'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=True, methods=['post'])
    def email(self, request, pk=None):
        """Send receipt via email"""
        receipt = self.get_object()
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        email_address = serializer.validated_data['email_address']
        custom_message = serializer.validated_data.get('custom_message', '')
        
        success = self._send_receipt_email(receipt, email_address, custom_message)
        
        if success:
            return Response({
                'message': 'Receipt sent successfully',
                'email_address': email_address
            })
        else:
            return Response(
                {'error': 'Failed to send email'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=True, methods=['post'])
    def print(self, request, pk=None):
        """Queue receipt for printing"""
        receipt = self.get_object()
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        printer_name = serializer.validated_data['printer_name']
        printer_type = serializer.validated_data.get('printer_type', 'thermal')
        copies = serializer.validated_data.get('copies', 1)
        priority = serializer.validated_data.get('priority', 5)
        
        success = self._queue_receipt_print(
            receipt, printer_name, printer_type, copies, priority
        )
        
        if success:
            return Response({
                'message': 'Receipt queued for printing',
                'printer': printer_name,
                'copies': copies
            })
        else:
            return Response(
                {'error': 'Failed to queue print'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=True, methods=['get'])
    def preview(self, request, pk=None):
        """Preview receipt HTML"""
        receipt = self.get_object()
        
        try:
            # Get receipt template
            template = ReceiptTemplate.objects.filter(
                template_type='sale', 
                is_active=True, 
                is_default=True
            ).first()
            
            if not template:
                template = ReceiptTemplate.objects.filter(
                    template_type='sale', 
                    is_active=True
                ).first()
            
            # Generate receipt data
            receipt_data = self._generate_receipt_data(receipt)
            
            # Render HTML (this would use your template system)
            receipt_html = self._render_receipt_html(receipt, template, receipt_data)
            
            serializer = ReceiptPreviewSerializer({
                'receipt_html': receipt_html,
                'receipt_data': receipt_data,
                'template_used': template.name if template else 'default',
                'estimated_print_lines': len(receipt_html.split('\n'))
            })
            
            return Response(serializer.data)
        
        except Exception as e:
            logger.error(f"Error previewing receipt {pk}: {str(e)}")
            return Response(
                {'error': 'Failed to generate preview'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=False, methods=['get'])
    def stats(self, request):
        """Get receipt statistics"""
        # Date filter
        days = int(request.query_params.get('days', 30))
        start_date = timezone.now() - timedelta(days=days)
        
        queryset = Receipt.objects.filter(created_at__gte=start_date, status='active')
        
        # Calculate stats
        stats = {
            'total_receipts': queryset.count(),
            'receipts_today': queryset.filter(created_at__date=timezone.now().date()).count(),
            'emailed_receipts': queryset.filter(is_emailed=True).count(),
            'printed_receipts': queryset.filter(is_printed=True).count(),
            'voided_receipts': Receipt.objects.filter(
                created_at__gte=start_date, status='voided'
            ).count(),
            'total_revenue': queryset.aggregate(
                total=Sum('total_amount')
            )['total'] or 0,
            'average_receipt_amount': queryset.aggregate(
                avg=Avg('total_amount')
            )['avg'] or 0
        }
        
        # Receipt type breakdown
        type_breakdown = list(queryset.values('receipt_type').annotate(
            count=Count('id'),
            revenue=Sum('total_amount')
        ))
        stats['receipt_type_breakdown'] = type_breakdown
        
        # Daily trends (last 7 days)
        daily_trends = []
        for i in range(7):
            date = (timezone.now() - timedelta(days=i)).date()
            daily_count = queryset.filter(created_at__date=date).count()
            daily_revenue = queryset.filter(created_at__date=date).aggregate(
                total=Sum('total_amount')
            )['total'] or 0
            
            daily_trends.append({
                'date': date.isoformat(),
                'receipts': daily_count,
                'revenue': float(daily_revenue)
            })
        
        stats['daily_trends'] = daily_trends
        
        serializer = ReceiptStatsSerializer(stats)
        return Response(serializer.data)
    
    @action(detail=False, methods=['post'])
    def bulk_action(self, request):
        """Perform bulk actions on receipts"""
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        receipt_ids = serializer.validated_data['receipt_ids']
        action_type = serializer.validated_data['action']
        
        receipts = Receipt.objects.filter(id__in=receipt_ids)
        
        try:
            with transaction.atomic():
                results = {
                    'processed': 0,
                    'failed': 0,
                    'errors': []
                }
                
                for receipt in receipts:
                    try:
                        if action_type == 'email':
                            email_address = serializer.validated_data['email_address']
                            if self._send_receipt_email(receipt, email_address):
                                results['processed'] += 1
                            else:
                                results['failed'] += 1
                                results['errors'].append(f"Failed to email {receipt.receipt_number}")
                        
                        elif action_type == 'print':
                            printer_name = serializer.validated_data['printer_name']
                            if self._queue_receipt_print(receipt, printer_name):
                                results['processed'] += 1
                            else:
                                results['failed'] += 1
                                results['errors'].append(f"Failed to print {receipt.receipt_number}")
                        
                        elif action_type == 'void' and request.user.has_perm('receipts.can_void_receipts'):
                            void_reason = serializer.validated_data['void_reason']
                            receipt.status = 'voided'
                            receipt.void_reason = void_reason
                            receipt.voided_by = request.user
                            receipt.voided_at = timezone.now()
                            receipt.save()
                            results['processed'] += 1
                        
                        elif action_type == 'regenerate':
                            # This would regenerate receipt data/numbers
                            receipt.receipt_data = self._generate_receipt_data(receipt)
                            receipt.save()
                            results['processed'] += 1
                    
                    except Exception as e:
                        results['failed'] += 1
                        results['errors'].append(f"Error processing {receipt.receipt_number}: {str(e)}")
                
                return Response(results)
        
        except Exception as e:
            logger.error(f"Bulk action error: {str(e)}")
            return Response(
                {'error': 'Bulk action failed'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    def _send_receipt_email(self, receipt, email_address, custom_message=''):
        """Send receipt via email"""
        try:
            # Generate receipt content
            receipt_data = self._generate_receipt_data(receipt)
            
            # Create email log entry
            email_log = ReceiptEmailLog.objects.create(
                receipt=receipt,
                email_address=email_address,
                subject=f'Receipt #{receipt.receipt_number}',
                status='sending',
                sent_by=self.request.user
            )
            
            # Prepare email
            subject = f'Receipt #{receipt.receipt_number} - {receipt_data["business_name"]}'
            
            # Render email template
            email_html = render_to_string('receipts/email_receipt.html', {
                'receipt': receipt,
                'receipt_data': receipt_data,
                'custom_message': custom_message
            })
            
            # Send email
            email = EmailMessage(
                subject=subject,
                body=email_html,
                from_email=settings.DEFAULT_FROM_EMAIL,
                to=[email_address]
            )
            email.content_subtype = 'html'
            
            # Attach PDF if configured
            # pdf_content = self._generate_receipt_pdf(receipt)
            # email.attach(f'receipt_{receipt.receipt_number}.pdf', pdf_content, 'application/pdf')
            
            email.send()
            
            # Update receipt and log
            receipt.is_emailed = True
            receipt.email_sent_at = timezone.now()
            receipt.save()
            
            email_log.status = 'sent'
            email_log.sent_at = timezone.now()
            email_log.save()
            
            logger.info(f"Receipt {receipt.receipt_number} emailed to {email_address}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to send receipt email: {str(e)}")
            if 'email_log' in locals():
                email_log.status = 'failed'
                email_log.error_message = str(e)
                email_log.save()
            return False
    
    def _queue_receipt_print(self, receipt, printer_name, printer_type='thermal', copies=1, priority=5):
        """Queue receipt for printing"""
        try:
            print_job = ReceiptPrintQueue.objects.create(
                receipt=receipt,
                printer_name=printer_name,
                printer_type=printer_type,
                copies=copies,
                priority=priority,
                status='queued',
                queued_by=self.request.user
            )
            
            # Update receipt print status
            receipt.is_printed = True
            receipt.print_count += copies
            receipt.save()
            
            logger.info(f"Receipt {receipt.receipt_number} queued for printing on {printer_name}")
            return True
        
        except Exception as e:
            logger.error(f"Failed to queue receipt print: {str(e)}")
            return False
    
    def _generate_receipt_data(self, receipt):
        """Generate receipt data for rendering"""
        return {
            'receipt_number': receipt.receipt_number,
            'business_name': receipt.business_name,
            'business_address': receipt.business_address,
            'business_phone': receipt.business_phone,
            'customer_name': receipt.customer_name,
            'customer_room': receipt.customer_room,
            'date_time': receipt.created_at.strftime('%Y-%m-%d %H:%M:%S'),
            'subtotal': receipt.subtotal,
            'tax_amount': receipt.tax_amount,
            'service_charge': receipt.service_charge,
            'total_amount': receipt.total_amount,
            'amount_paid': receipt.amount_paid,
            'change_amount': receipt.change_amount,
            'payment_method': receipt.get_payment_method_display(),
            'items': [
                {
                    'name': item.item_name,
                    'quantity': item.quantity,
                    'price': item.unit_price,
                    'total': item.line_total
                }
                for item in receipt.items.all()
            ]
        }
    
    def _render_receipt_html(self, receipt, template, receipt_data):
        """Render receipt HTML"""
        if template:
            return render_to_string('receipts/receipt_template.html', {
                'receipt': receipt,
                'receipt_data': receipt_data,
                'template': template
            })
        else:
            return render_to_string('receipts/default_receipt.html', {
                'receipt': receipt,
                'receipt_data': receipt_data
            })

class ReceiptTemplateViewSet(viewsets.ModelViewSet):
    """Receipt template management ViewSet"""
    
    queryset = ReceiptTemplate.objects.all()
    serializer_class = ReceiptTemplateSerializer
    permission_classes = [IsAuthenticated, IsManagerOrAdmin]
    
    def get_queryset(self):
        """Get templates with filtering"""
        queryset = super().get_queryset()
        
        template_type = self.request.query_params.get('template_type')
        if template_type:
            queryset = queryset.filter(template_type=template_type)
        
        is_active = self.request.query_params.get('is_active')
        if is_active is not None:
            queryset = queryset.filter(is_active=is_active.lower() == 'true')
        
        return queryset.order_by('template_type', 'name')
    
    @action(detail=True, methods=['post'])
    def set_default(self, request, pk=None):
        """Set template as default for its type"""
        template = self.get_object()
        
        try:
            with transaction.atomic():
                # Remove default from other templates of same type
                ReceiptTemplate.objects.filter(
                    template_type=template.template_type,
                    is_default=True
                ).update(is_default=False)
                
                # Set this template as default
                template.is_default = True
                template.save()
                
                return Response({
                    'message': f'Template {template.name} set as default for {template.template_type}'
                })
        
        except Exception as e:
            logger.error(f"Error setting default template: {str(e)}")
            return Response(
                {'error': 'Failed to set default template'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class ReceiptPrintQueueViewSet(viewsets.ModelViewSet):
    """Receipt print queue ViewSet"""
    
    queryset = ReceiptPrintQueue.objects.select_related('receipt', 'queued_by')
    serializer_class = ReceiptPrintQueueSerializer
    permission_classes = [IsAuthenticated, IsStaffMember]
    
    def get_queryset(self):
        """Get print queue with filtering"""
        queryset = super().get_queryset()
        
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        printer_name = self.request.query_params.get('printer_name')
        if printer_name:
            queryset = queryset.filter(printer_name=printer_name)
        
        return queryset.order_by('priority', 'queued_at')
    
    @action(detail=True, methods=['post'])
    def mark_printed(self, request, pk=None):
        """Mark print job as completed"""
        print_job = self.get_object()
        
        try:
            print_job.status = 'printed'
            print_job.printed_at = timezone.now()
            print_job.save()
            
            return Response({
                'message': 'Print job marked as completed',
                'receipt_number': print_job.receipt.receipt_number
            })
        
        except Exception as e:
            logger.error(f"Error marking print job as completed: {str(e)}")
            return Response(
                {'error': 'Failed to update print job'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
    
    @action(detail=True, methods=['post'])
    def mark_failed(self, request, pk=None):
        """Mark print job as failed"""
        print_job = self.get_object()
        error_message = request.data.get('error_message', 'Print failed')
        
        try:
            print_job.status = 'failed'
            print_job.error_message = error_message
            print_job.print_attempts += 1
            print_job.save()
            
            return Response({
                'message': 'Print job marked as failed',
                'error_message': error_message
            })
        
        except Exception as e:
            logger.error(f"Error marking print job as failed: {str(e)}")
            return Response(
                {'error': 'Failed to update print job'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class ReceiptEmailLogViewSet(viewsets.ReadOnlyModelViewSet):
    """Receipt email log ViewSet (read-only)"""
    
    queryset = ReceiptEmailLog.objects.select_related('receipt', 'sent_by')
    serializer_class = ReceiptEmailLogSerializer
    permission_classes = [IsAuthenticated, IsStaffMember]
    
    def get_queryset(self):
        """Get email logs with filtering"""
        queryset = super().get_queryset()
        
        status_filter = self.request.query_params.get('status')
        if status_filter:
            queryset = queryset.filter(status=status_filter)
        
        receipt_id = self.request.query_params.get('receipt')
        if receipt_id:
            queryset = queryset.filter(receipt_id=receipt_id)
        
        return queryset.order_by('-created_at')